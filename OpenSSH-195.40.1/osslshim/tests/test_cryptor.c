/*
 * Copyright (c) 2011-12 Apple Inc. All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>

#include "ossl-evp.h"
#include "ossl-evp-cc.h"

#include "test_common.h"

static int verbose = 1;

static int total = 0;
static int pass = 0;
static int fail = 0;

/*
 *  Cryptor Test Engine.
 */
typedef const EVP_CIPHER * (*evp_alg_t)(void);

static int _test_cryptor(evp_alg_t alg, const byteVector_t *key[], const byteVector_t *pt[], const byteVector_t *ct[], const unsigned num_tests)
{
	unsigned i;
	int rv = 0;
	EVP_CIPHER_CTX ectx, dctx;
	const EVP_CIPHER  *c = (*alg)();

	if (NULL == c) {
		printf("cipher not supported\n");
		return (1);
	}

	EVP_CIPHER_CTX_init(&ectx);
	EVP_CIPHER_CTX_init(&dctx);

	/* Setup key */
	for(i = 0; i < num_tests; i++) {
		size_t blocksize = (pt[i]->len > ct[i]->len) ? pt[i]->len : ct[i]->len;
		uint8_t blk1[blocksize], blk2[blocksize];

		if (EVP_CipherInit_ex(&ectx, c, NULL, NULL, NULL, 1) != 1) {
			if (verbose) printf("vector %u EVP_EncryptInit_ex failed\n", i);
			continue;
		}
		if (EVP_CipherInit_ex(&dctx, c, NULL, NULL, NULL, 0) != 1) {
			if (verbose) printf("vector %u EVP_DecryptInit_ex failed\n",  i);
			EVP_CIPHER_CTX_cleanup(&ectx);
			continue;
		}

		EVP_CIPHER_CTX_set_key_length(&ectx, key[i]->len);
		EVP_CIPHER_CTX_set_key_length(&dctx, key[i]->len);

		if (EVP_CipherInit_ex(&ectx, c, NULL, key[i]->value, NULL, 1) != 1) {
			if (verbose) printf("vector %u EVP_EncryptInit_ex w/ key failed\n", i);
			EVP_CIPHER_CTX_cleanup(&ectx);
			EVP_CIPHER_CTX_cleanup(&dctx);
			continue;
		}
		if (EVP_CipherInit_ex(&dctx, c, NULL, key[i]->value, NULL, 0) != 1) {
			if (verbose) printf("vector %u EVP_DecryptInit_ex w/ key failed\n",  i);
			EVP_CIPHER_CTX_cleanup(&ectx);
			EVP_CIPHER_CTX_cleanup(&dctx);
			continue;
		}



		/* Encrypt and decrypt. */
		if (!EVP_Cipher(&ectx, blk1, pt[i]->value, blocksize)) {
			if (verbose) printf("encrypting failed on vector %u\n", i);
			rv = 1;
			goto done;
		}
		if (memcmp(blk1, ct[i]->value, blocksize) != 0) {
#if 0
			char *s1, *s2;

			if (verbose) {
				hex_encode(blk1, blocksize, &s1);
				hex_encode(ct[i]->value, blocksize, &s2);

				printf("vector %d encrypt not the same: %s != %s\n", (int)i, s1, s2);
			}
#else
			if (verbose) printf("vector %u encrypt not the same\n", i);
#endif
			rv = 1;
			goto done;
		}

		if (!EVP_Cipher(&dctx, blk2, blk1, blocksize)) {
			if (verbose) printf("decrypting failed on vector %u\n", i);
			rv = 1;
			goto done;
		}
		if (memcmp(blk2, pt[i]->value, blocksize) != 0) {
#if 0
			char *s1, *s2;

			if (verbose) {
				hex_encode(blk2, blocksize, &s1);
				hex_encode(pt[i]->value, blocksize, &s2);

				printf("vector %d decrypt not the same: %s != %s\n", (int)i, s1, s2);
			}
#else
			if (verbose) printf("vector %u encrypt not the same\n", i);
#endif
			rv = 1;
			goto done;
		}

done:
		EVP_CIPHER_CTX_cleanup(&ectx);
		EVP_CIPHER_CTX_cleanup(&dctx);
	}

	return (rv);
}

/*
 * Test Vector Macros:
 *
 * CRYPTOR_KEY() is the key for the cryptor (in hex).
 * Parameters: (<Digest Name>, <vector #>, <key length>,  <vector data>)
 *
 * CRYPTOR_PT() is the plaintext (in hex).
 * CRYPTOR_CT() is the ciphertext digest (in hex).
 * Parameters: (<Digest Name>, <vector #>, <vector data>)
 */
#define	CRYPTOR_KEY(NAME, N, LEN, VALUE...) static byteVector_t	_cc_ ## NAME ## _cryptor_key_ ## N = \
						{ LEN, { VALUE } };
#define	CRYPTOR_PT(NAME, N, LEN, VALUE...) static byteVector_t _cc_ ## NAME ## _cryptor_pt_ ## N = \
						{ LEN, { VALUE } };
#define	CRYPTOR_CT(NAME, N, LEN, VALUE...) static byteVector_t _cc_ ## NAME ## _cryptor_ct_ ## N = \
						{ LEN, { VALUE } };

/*
 * CRYPTOR_TEST() generates the testing code stub.
 * Parameters: (<Cryptor Name>, <Number of test vectors>)
 */
#define	CRYPTOR_TEST(ALG_NAME, NUM_TESTS) 						\
static byteVector_t * _cc_ ## ALG_NAME ## _cryptor_key_vects[] =			\
	{ ARRAY_FOR_ ## NUM_TESTS (& _cc_ ## ALG_NAME ## _cryptor_key_ ) NULL };	\
											\
static byteVector_t * _cc_ ## ALG_NAME ## _cryptor_pt_vects[] =				\
	{ ARRAY_FOR_ ## NUM_TESTS (& _cc_ ## ALG_NAME ## _cryptor_pt_ ) NULL };		\
											\
static byteVector_t * _cc_ ## ALG_NAME ## _cryptor_ct_vects[] =				\
	{ ARRAY_FOR_ ## NUM_TESTS (& _cc_ ## ALG_NAME ## _cryptor_ct_ ) NULL };		\
											\
static int testCryptor_ ## ALG_NAME(void) {						\
	return (_test_cryptor(EVP_ ## ALG_NAME, 					\
		_cc_ ## ALG_NAME ## _cryptor_key_vects,					\
		_cc_ ## ALG_NAME ## _cryptor_pt_vects,					\
		_cc_ ## ALG_NAME ## _cryptor_ct_vects, NUM_TESTS));			\
}

/*
 * AES (Advanced Encryption Standard - FIPS 197) test vectors.
 */
CRYPTOR_KEY(aes_128_ecb, 0, 16,	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f)
CRYPTOR_PT(aes_128_ecb,  0, 16,	0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
				0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff)
CRYPTOR_CT(aes_128_ecb,  0, 16,	0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
				0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a)
CRYPTOR_TEST(aes_128_ecb, 1)

CRYPTOR_KEY(aes_192_ecb, 0, 24,	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17)
CRYPTOR_PT(aes_192_ecb,  0, 16,	0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
				0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff)
CRYPTOR_CT(aes_192_ecb,  0, 16,	0xdd, 0xa9, 0x7c, 0xa4, 0x86, 0x4c, 0xdf, 0xe0,
				0x6e, 0xaf, 0x70, 0xa0, 0xec, 0x0d, 0x71, 0x91)
CRYPTOR_TEST(aes_192_ecb, 1)

CRYPTOR_KEY(aes_256_ecb, 0, 32,	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
				0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f)
CRYPTOR_PT(aes_256_ecb,  0, 16,	0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
				0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff)
CRYPTOR_CT(aes_256_ecb,  0, 16,	0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf,
				0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89)
CRYPTOR_TEST(aes_256_ecb, 1)

/*
 * DES (Data Encryption Standard - FIPS 46-3) test vectors.
 */
CRYPTOR_KEY(des_ecb, 0, 8,	0x10, 0x31, 0x6E, 0x02, 0x8C, 0x8F, 0x3B, 0x4A)
CRYPTOR_PT(des_ecb,  0, 8,	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_CT(des_ecb,  0, 8,	0x82, 0xDC, 0xBA, 0xFB, 0xDE, 0xAB, 0x66, 0x02)

CRYPTOR_KEY(des_ecb, 1, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  1, 8,	0x95, 0xF8, 0xA5, 0xE5, 0xDD, 0x31, 0xD9, 0x00)
CRYPTOR_CT(des_ecb,  1, 8,	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)

CRYPTOR_KEY(des_ecb, 2, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  2, 8,	0xDD, 0x7F, 0x12, 0x1C, 0xA5, 0x01, 0x56, 0x19)
CRYPTOR_CT(des_ecb,  2, 8,	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)

CRYPTOR_KEY(des_ecb, 3, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  3, 8,	0x2E, 0x86, 0x53, 0x10, 0x4F, 0x38, 0x34, 0xEA)
CRYPTOR_CT(des_ecb,  3, 8,	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)

CRYPTOR_KEY(des_ecb, 4, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  4, 8,	0x4B, 0xD3, 0x88, 0xFF, 0x6C, 0xD8, 0x1D, 0x4F)
CRYPTOR_CT(des_ecb,  4, 8,	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)

CRYPTOR_KEY(des_ecb, 5, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  5, 8,	0x20, 0xB9, 0xE7, 0x67, 0xB2, 0xFB, 0x14, 0x56)
CRYPTOR_CT(des_ecb,  5, 8,	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)

CRYPTOR_KEY(des_ecb, 6, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  6, 8,	0x55, 0x57, 0x93, 0x80, 0xD7, 0x71, 0x38, 0xEF)
CRYPTOR_CT(des_ecb,  6, 8,	0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)

CRYPTOR_KEY(des_ecb, 7, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  7, 8,	0x6C, 0xC5, 0xDE, 0xFA, 0xAF, 0x04, 0x51, 0x2F)
CRYPTOR_CT(des_ecb,  7, 8,	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)

CRYPTOR_KEY(des_ecb, 8, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  8, 8,	0x0D, 0x9F, 0x27, 0x9B, 0xA5, 0xD8, 0x72, 0x60)
CRYPTOR_CT(des_ecb,  8, 8,	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)

CRYPTOR_KEY(des_ecb, 9, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  9, 8,	0xD9, 0x03, 0x1B, 0x02, 0x71, 0xBD, 0x5A, 0x0A)
CRYPTOR_CT(des_ecb,  9, 8,	0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
        
CRYPTOR_KEY(des_ecb, 10, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  10, 8,	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_CT(des_ecb,  10, 8,	0x95, 0xF8, 0xA5, 0xE5, 0xDD, 0x31, 0xD9, 0x00)

CRYPTOR_KEY(des_ecb, 11, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  11, 8,	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_CT(des_ecb,  11, 8,	0xDD, 0x7F, 0x12, 0x1C, 0xA5, 0x01, 0x56, 0x19)

CRYPTOR_KEY(des_ecb, 12, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  12, 8,	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_CT(des_ecb,  12, 8,	0x2E, 0x86, 0x53, 0x10, 0x4F, 0x38, 0x34, 0xEA)

CRYPTOR_KEY(des_ecb, 13, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  13, 8,	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_CT(des_ecb,  13, 8,	0x4B, 0xD3, 0x88, 0xFF, 0x6C, 0xD8, 0x1D, 0x4F)

CRYPTOR_KEY(des_ecb, 14, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  14, 8,	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_CT(des_ecb,  14, 8,	0x20, 0xB9, 0xE7, 0x67, 0xB2, 0xFB, 0x14, 0x56)

CRYPTOR_KEY(des_ecb, 15, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  15, 8,	0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_CT(des_ecb,  15, 8,	0x55, 0x57, 0x93, 0x80, 0xD7, 0x71, 0x38, 0xEF)

CRYPTOR_KEY(des_ecb, 16, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  16, 8,	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_CT(des_ecb,  16, 8,	0x6C, 0xC5, 0xDE, 0xFA, 0xAF, 0x04, 0x51, 0x2F)

CRYPTOR_KEY(des_ecb, 17, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  17, 8,	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_CT(des_ecb,  17, 8,	0x0D, 0x9F, 0x27, 0x9B, 0xA5, 0xD8, 0x72, 0x60)

CRYPTOR_KEY(des_ecb, 18, 8,	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01)
CRYPTOR_PT(des_ecb,  18, 8,	0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_CT(des_ecb,  18, 8,	0xD9, 0x03, 0x1B, 0x02, 0x71, 0xBD, 0x5A, 0x0A)

        
        /*** more test cases you could add if you are not convinced (the above test cases aren't really too good):
         
         key              plaintext        ciphertext
         0000000000000000 0000000000000000 8CA64DE9C1B123A7
         FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF 7359B2163E4EDC58
         3000000000000000 1000000000000001 958E6E627A05557B
         1111111111111111 1111111111111111 F40379AB9E0EC533
         0123456789ABCDEF 1111111111111111 17668DFC7292532D
         1111111111111111 0123456789ABCDEF 8A5AE1F81AB8F2DD
         0000000000000000 0000000000000000 8CA64DE9C1B123A7
         FEDCBA9876543210 0123456789ABCDEF ED39D950FA74BCC4
         7CA110454A1A6E57 01A1D6D039776742 690F5B0D9A26939B
         0131D9619DC1376E 5CD54CA83DEF57DA 7A389D10354BD271
         07A1133E4A0B2686 0248D43806F67172 868EBB51CAB4599A
         3849674C2602319E 51454B582DDF440A 7178876E01F19B2A
         04B915BA43FEB5B6 42FD443059577FA2 AF37FB421F8C4095
         0113B970FD34F2CE 059B5E0851CF143A 86A560F10EC6D85B
         0170F175468FB5E6 0756D8E0774761D2 0CD3DA020021DC09
         43297FAD38E373FE 762514B829BF486A EA676B2CB7DB2B7A
         07A7137045DA2A16 3BDD119049372802 DFD64A815CAF1A0F
         04689104C2FD3B2F 26955F6835AF609A 5C513C9C4886C088
         37D06BB516CB7546 164D5E404F275232 0A2AEEAE3FF4AB77
         1F08260D1AC2465E 6B056E18759F5CCA EF1BF03E5DFA575A
         584023641ABA6176 004BD6EF09176062 88BF0DB6D70DEE56
         025816164629B007 480D39006EE762F2 A1F9915541020B56
         49793EBC79B3258F 437540C8698F3CFA 6FBF1CAFCFFD0556
         4FB05E1515AB73A7 072D43A077075292 2F22E49BAB7CA1AC
         49E95D6D4CA229BF 02FE55778117F12A 5A6B612CC26CCE4A
         018310DC409B26D6 1D9D5C5018F728C2 5F4C038ED12B2E41
         1C587F1C13924FEF 305532286D6F295A 63FAC0D034D9F793
         0101010101010101 0123456789ABCDEF 617B3A0CE8F07100
         1F1F1F1F0E0E0E0E 0123456789ABCDEF DB958605F8C8C606
         E0FEE0FEF1FEF1FE 0123456789ABCDEF EDBFD1C66C29CCC7
         0000000000000000 FFFFFFFFFFFFFFFF 355550B2150E2451
         FFFFFFFFFFFFFFFF 0000000000000000 CAAAAF4DEAF1DBAE
         0123456789ABCDEF 0000000000000000 D5D44FF720683D0D
         FEDCBA9876543210 FFFFFFFFFFFFFFFF 2A2BB008DF97C2F2
         
         http://www.ecs.soton.ac.uk/~prw99r/ez438/vectors.txt
         ***/
CRYPTOR_TEST(des_ecb, 19)

/*
 * CAST Test Vectors.
 */
CRYPTOR_KEY(cast5_ecb, 0, 16,	0x01, 0x23, 0x45, 0x67, 0x12, 0x34, 0x56, 0x78,
				0x23, 0x45, 0x67, 0x89, 0x34, 0x56, 0x78, 0x9A)
CRYPTOR_PT(cast5_ecb,  0, 8,	0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF)
CRYPTOR_CT(cast5_ecb,  0, 8,	0x23, 0x8B, 0x4F, 0xE5, 0x84, 0x7E, 0x44, 0xB2)

CRYPTOR_KEY(cast5_ecb, 1, 10,	0x01, 0x23, 0x45, 0x67, 0x12, 0x34, 0x56, 0x78,
				0x23, 0x45)
CRYPTOR_PT(cast5_ecb,  1, 8,	0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF)
CRYPTOR_CT(cast5_ecb,  1, 8,	0xEB, 0x6A, 0x71, 0x1A, 0x2C, 0x02, 0x27, 0x1B)

CRYPTOR_KEY(cast5_ecb, 2, 5,	0x01, 0x23, 0x45, 0x67, 0x12)
CRYPTOR_PT(cast5_ecb,  2, 8,	0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF)
CRYPTOR_CT(cast5_ecb,  2, 8,	0x7A, 0xC8, 0x16, 0xD1, 0x6E, 0x9B, 0x30, 0x2E)

CRYPTOR_TEST(cast5_ecb, 3)

#if 0  /* NO RC2 support */
/*
 * RC2 Test Vectors.
 */
CRYPTOR_KEY(RC2, 0, 8,	0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_PT(RC2,  0, 8,	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01)
CRYPTOR_CT(RC2,  0, 8,	0x30, 0x64, 0x9e, 0xdf, 0x9b, 0xe7, 0xd2, 0xc2)

CRYPTOR_KEY(RC2, 1, 16,	0x88, 0xbc, 0xa9, 0x0e, 0x90, 0x87, 0x5a, 0x7f,
			0x0f, 0x79, 0xc3, 0x84, 0x62, 0x7b, 0xaf, 0xb2)
CRYPTOR_PT(RC2,  1, 8,	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_CT(RC2,	 1, 8,	0x22, 0x69, 0x55, 0x2a, 0xb0, 0xf8, 0x5c, 0xa6)

CRYPTOR_TEST(RC2, 2)
#endif

/*
 * Blowfish Test Vectors.
 */
CRYPTOR_KEY(bf_ecb, 0, 8,	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_PT(bf_ecb,  0, 8,	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_CT(bf_ecb,  0, 8,	0x4E, 0xF9, 0x97, 0x45, 0x61, 0x98, 0xDD, 0x78)

CRYPTOR_KEY(bf_ecb, 1, 8,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF)
CRYPTOR_PT(bf_ecb,  1, 8,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF)
CRYPTOR_CT(bf_ecb,  1, 8,	0x51, 0x86, 0x6F, 0xD5, 0xB8, 0x5E, 0xCB, 0x8A)

CRYPTOR_KEY(bf_ecb, 2, 8,	0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
CRYPTOR_PT(bf_ecb,  2, 8,	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01)
CRYPTOR_CT(bf_ecb,  2, 8,	0x7D, 0x85, 0x6F, 0x9A, 0x61, 0x30, 0x63, 0xF2)

CRYPTOR_TEST(bf_ecb, 3)

/*
 * TDES (Triple Data Encryption Standard - NIST Special Pub 800-67) custom test.
 *
 * Test vectors are from Jeroen C. van Gelderen.
 */
CRYPTOR_KEY(des_ede3_ecb, 0, 24,	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
					0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
					0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01)
CRYPTOR_PT(des_ede3_ecb,  0, 8,		0x95,0xF8,0xA5,0xE5,0xDD,0x31,0xD9,0x00)
CRYPTOR_CT(des_ede3_ecb,  0, 8,		0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00)

CRYPTOR_KEY(des_ede3_ecb, 1, 24,	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
					0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
					0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01)
CRYPTOR_PT(des_ede3_ecb,  1, 8,		0x9D,0x64,0x55,0x5A,0x9A,0x10,0xB8,0x52)
CRYPTOR_CT(des_ede3_ecb,  1, 8,		0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00)

CRYPTOR_KEY(des_ede3_ecb, 2, 24,	0x38,0x49,0x67,0x4C,0x26,0x02,0x31,0x9E,
    					0x38,0x49,0x67,0x4C,0x26,0x02,0x31,0x9E,
					0x38,0x49,0x67,0x4C,0x26,0x02,0x31,0x9E)
CRYPTOR_PT(des_ede3_ecb,  2, 8,		0x51,0x45,0x4B,0x58,0x2D,0xDF,0x44,0x0A)
CRYPTOR_CT(des_ede3_ecb,  2, 8,		0x71,0x78,0x87,0x6E,0x01,0xF1,0x9B,0x2A)

CRYPTOR_KEY(des_ede3_ecb, 3, 24,	0x04,0xB9,0x15,0xBA,0x43,0xFE,0xB5,0xB6,
					0x04,0xB9,0x15,0xBA,0x43,0xFE,0xB5,0xB6,
					0x04,0xB9,0x15,0xBA,0x43,0xFE,0xB5,0xB6)
CRYPTOR_PT(des_ede3_ecb,  3, 8,		0x42,0xFD,0x44,0x30,0x59,0x57,0x7F,0xA2)
CRYPTOR_CT(des_ede3_ecb,  3, 8,		0xAF,0x37,0xFB,0x42,0x1F,0x8C,0x40,0x95)

CRYPTOR_KEY(des_ede3_ecb, 4, 24,	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
					0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
					0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF)
CRYPTOR_PT(des_ede3_ecb,  4, 8,		0x73,0x6F,0x6D,0x65,0x64,0x61,0x74,0x61)
CRYPTOR_CT(des_ede3_ecb,  4, 8,		0x3D,0x12,0x4F,0xE2,0x19,0x8B,0xA3,0x18)

CRYPTOR_KEY(des_ede3_ecb, 5, 24,	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
					0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
					0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF)
CRYPTOR_PT(des_ede3_ecb,  5, 8,		0x73,0x6F,0x6D,0x65,0x64,0x61,0x74,0x61)
CRYPTOR_CT(des_ede3_ecb,  5, 8,		0xFB,0xAB,0xA1,0xFF,0x9D,0x05,0xE9,0xB1)

CRYPTOR_KEY(des_ede3_ecb, 6, 24, 	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
					0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,
					0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10)
CRYPTOR_PT(des_ede3_ecb,  6, 8,		0x73,0x6F,0x6D,0x65,0x64,0x61,0x74,0x61)
CRYPTOR_CT(des_ede3_ecb,  6, 8,		0x18,0xd7,0x48,0xe5,0x63,0x62,0x05,0x72)

CRYPTOR_KEY(des_ede3_ecb, 7, 24,	0x03,0x52,0x02,0x07,0x67,0x20,0x82,0x17,
					0x86,0x02,0x87,0x66,0x59,0x08,0x21,0x98,
					0x64,0x05,0x6A,0xBD,0xFE,0xA9,0x34,0x57)
CRYPTOR_PT(des_ede3_ecb,  7, 8,		0x73,0x71,0x75,0x69,0x67,0x67,0x6C,0x65)
CRYPTOR_CT(des_ede3_ecb,  7, 8,		0xc0,0x7d,0x2a,0x0f,0xa5,0x66,0xfa,0x30)

CRYPTOR_KEY(des_ede3_ecb, 8, 24, 	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
					0x80,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
					0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02)
CRYPTOR_PT(des_ede3_ecb,  8, 8,		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00)
CRYPTOR_CT(des_ede3_ecb,  8, 8,		0xe6,0xe6,0xdd,0x5b,0x7e,0x72,0x29,0x74)

CRYPTOR_KEY(des_ede3_ecb, 9, 24,	0x10,0x46,0x10,0x34,0x89,0x98,0x80,0x20,
					0x91,0x07,0xD0,0x15,0x89,0x19,0x01,0x01,
					0x19,0x07,0x92,0x10,0x98,0x1A,0x01,0x01)
CRYPTOR_PT(des_ede3_ecb,  9, 8,		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00)
CRYPTOR_CT(des_ede3_ecb,  9, 8,		0xe1,0xef,0x62,0xc3,0x32,0xfe,0x82,0x5b)

CRYPTOR_TEST(des_ede3_ecb, 3)


/*
 * RC4 test vecotors.
 */
CRYPTOR_KEY(rc4, 0, 8,		0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef)
CRYPTOR_PT(rc4,  0, 8,		0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef)
CRYPTOR_CT(rc4,  0, 8,		0x75,0xb7,0x87,0x80,0x99,0xe0,0xc5,0x96)

CRYPTOR_KEY(rc4, 1, 8,		0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef)
CRYPTOR_PT(rc4,  1, 8,		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00)
CRYPTOR_CT(rc4,  1, 8,		0x74,0x94,0xc2,0xe7,0x10,0x4b,0x08,0x79)

CRYPTOR_KEY(rc4, 2, 8,		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00)
CRYPTOR_PT(rc4,  2, 8,		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00)
CRYPTOR_CT(rc4,  2, 8,		0xde,0x18,0x89,0x41,0xa3,0x37,0x5d,0x3a)

CRYPTOR_KEY(rc4, 3, 4,		0xef,0x01,0x23,0x45)
CRYPTOR_PT(rc4,  3, 20,		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00)
CRYPTOR_CT(rc4,  3, 20,		0xd6,0xa1,0x41,0xa7,0xec,0x3c,0x38,0xdf,
				0xbd,0x61,0x5a,0x11,0x62,0xe1,0xc7,0xba,
				0x36,0xb6,0x78,0x58)

CRYPTOR_KEY(rc4, 4, 4,		0xef,0x01,0x23,0x45)
CRYPTOR_PT(rc4,  4, 10,		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00)
CRYPTOR_CT(rc4,	 4, 10,		0xd6,0xa1,0x41,0xa7,0xec,0x3c,0x38,0xdf,
				0xbd,0x61)

CRYPTOR_TEST(rc4, 5)


/*
 * Cryptor test functions array.
 */
static testFunction_t cryptorTestFunctions[] = {
    { testCryptor_aes_128_ecb,	"aes-128-ecb" },
    { testCryptor_aes_192_ecb,	"aes-192-ecb" },
    { testCryptor_aes_256_ecb,	"aes-256-ecb" },
    { testCryptor_des_ecb,	"des-ecb" },
    { testCryptor_des_ede3_ecb,	"des-ede3-ecb" },
    { testCryptor_cast5_ecb,	"cast5-ecb" },
    { testCryptor_rc4,		"rc4" },
#if 0
    { testCryptorRC2,	"RC2" },
#endif
    { testCryptor_bf_ecb, "Blowfish" },
};
#define numCryptorTestFunctions  (sizeof(cryptorTestFunctions) / sizeof(cryptorTestFunctions[0]))

static int
testAllCryptors(void)
{
	unsigned i;
	int err = 0;

	for (i = 0; i < numCryptorTestFunctions; i++) {
		if (NULL == cryptorTestFunctions[i].description) continue;
		if (verbose) printf("[BEGIN] %s\n", cryptorTestFunctions[i].description);
		err = cryptorTestFunctions[i].funcptr();
		total++;
		if (err) {
			fail++;
			if (verbose) printf("[FAIL] %s\n", cryptorTestFunctions[i].description);
		} else {
			pass++;
			if (verbose) printf("[PASS] %s\n", cryptorTestFunctions[i].description);
		}
	}
	return (fail);
}

/***************************************************************************************/

/*
 * Mode Test Engine.
 */
static int _test_mode(evp_alg_t alg, const byteVector_t *key[], const byteVector_t *iv[], const byteVector_t *pt[], const byteVector_t *ct[], const unsigned num_tests)
{
	unsigned i;
	int rv = 0;
	EVP_CIPHER_CTX ectx, dctx;
	const EVP_CIPHER  *c = (*alg)();

	if (NULL == c) {
		printf("cipher not supported\n");
		return (1);
	}

	EVP_CIPHER_CTX_init(&ectx);
	EVP_CIPHER_CTX_init(&dctx);

	/* Setup key */
	for(i = 0; i < num_tests; i++) {
		size_t blocksize = (pt[i]->len > ct[i]->len) ? pt[i]->len : ct[i]->len;
		uint8_t blk1[blocksize], blk2[blocksize];

		if (EVP_CipherInit_ex(&ectx, c, NULL, NULL, NULL, 1) != 1) {
			if (verbose) printf("vector %u EVP_EncryptInit_ex failed\n", i);
			continue;
		}
		if (EVP_CipherInit_ex(&dctx, c, NULL, NULL, NULL, 0) != 1) {
			if (verbose) printf("vector %u EVP_DecryptInit_ex failed\n",  i);
			EVP_CIPHER_CTX_cleanup(&ectx);
			continue;
		}

		EVP_CIPHER_CTX_set_key_length(&ectx, key[i]->len);
		EVP_CIPHER_CTX_set_key_length(&dctx, key[i]->len);

		if (EVP_CipherInit_ex(&ectx, c, NULL, key[i]->value, iv[i]->value, 1) != 1) {
			if (verbose) printf("vector %u EVP_EncryptInit_ex w/ key failed\n", i);
			EVP_CIPHER_CTX_cleanup(&ectx);
			EVP_CIPHER_CTX_cleanup(&dctx);
			continue;
		}
		if (EVP_CipherInit_ex(&dctx, c, NULL, key[i]->value, iv[i]->value, 0) != 1) {
			if (verbose) printf("vector %u EVP_DecryptInit_ex w/ key failed\n",  i);
			EVP_CIPHER_CTX_cleanup(&ectx);
			EVP_CIPHER_CTX_cleanup(&dctx);
			continue;
		}



		/* Encrypt and decrypt. */
		if (!EVP_Cipher(&ectx, blk1, pt[i]->value, blocksize)) {
			if (verbose) printf("encrypting failed on vector %u\n", i);
			rv = 1;
			goto done;
		}
		if (memcmp(blk1, ct[i]->value, blocksize) != 0) {
#if 0
			char *s1, *s2;

			if (verbose) {
				hex_encode(blk1, blocksize, &s1);
				hex_encode(ct[i]->value, blocksize, &s2);

				printf("vector %d encrypt not the same: %s != %s\n", (int)i, s1, s2);
			}
#else
			if (verbose) printf("vector %u encrypt not the same\n", i);
#endif
			rv = 1;
			goto done;
		}

		if (!EVP_Cipher(&dctx, blk2, blk1, blocksize)) {
			if (verbose) printf("decrypting failed on vector %u\n", i);
			rv = 1;
			goto done;
		}
		if (memcmp(blk2, pt[i]->value, blocksize) != 0) {
#if 0
			char *s1, *s2;

			if (verbose) {
				hex_encode(blk2, blocksize, &s1);
				hex_encode(pt[i]->value, blocksize, &s2);

				printf("vector %d decrypt not the same: %s != %s\n", (int)i, s1, s2);
			}
#else
			if (verbose) printf("vector %u encrypt not the same\n", i);
#endif
			rv = 1;
			goto done;
		}

done:
		EVP_CIPHER_CTX_cleanup(&ectx);
		EVP_CIPHER_CTX_cleanup(&dctx);
	}

	return (rv);
}

/*
 * Test Vector Macros:
 *
 * MODE_KEY() is the key for the cryptor (in hex).
 * MODE_IV() is the initialization vector (in hex).
 * Parameters: (<Mode Name>, <vector #>, <key length>,  <vector data>)
 *
 * MODE_PT() is the plaintext (in hex).
 * MODE_CT() is the ciphertext digest (in hex).
 * Parameters: (<Mode Name>, <vector #>, <vector size>, <vector data>)
 */
#define	MODE_KEY(NAME, N, LEN, VALUE...) static byteVector_t	NAME ## _mode_key_ ## N = \
						{ LEN, { VALUE } };
#define	MODE_IV(NAME, N, LEN, VALUE...) static byteVector_t	NAME ## _mode_iv_ ## N = \
						{ LEN, { VALUE } };
#define	MODE_PT(NAME, N, LEN, VALUE...)	static byteVector_t	NAME ## _mode_pt_ ## N = \
						{ LEN, { VALUE } };
#define	MODE_CT(NAME, N, LEN, VALUE...)	static byteVector_t	NAME ## _mode_ct_ ## N = \
						{ LEN, { VALUE } };

/*
 * MODE_TEST() generates the testing code stub.
 * Parameters: (<Mode Name>, <Number of test vectors>)
 */
#define	MODE_TEST(ALG_NAME, NUM_TESTS) 							\
static byteVector_t * ALG_NAME ## _mode_key_vects[] =					\
	{ ARRAY_FOR_ ## NUM_TESTS (& ALG_NAME ## _mode_key_ ) NULL };			\
											\
static byteVector_t * ALG_NAME ## _mode_iv_vects[] =					\
	{ ARRAY_FOR_ ## NUM_TESTS (& ALG_NAME ## _mode_iv_ ) NULL };			\
											\
static byteVector_t * ALG_NAME ## _mode_pt_vects[] =					\
	{ ARRAY_FOR_ ## NUM_TESTS (& ALG_NAME ## _mode_pt_ ) NULL };			\
											\
static byteVector_t * ALG_NAME ## _mode_ct_vects[] =					\
	{ ARRAY_FOR_ ## NUM_TESTS (& ALG_NAME ## _mode_ct_ ) NULL };			\
											\
static int testMode_ ## ALG_NAME(void) {							\
	return (_test_mode(EVP_ ## ALG_NAME, ALG_NAME ## _mode_key_vects,		\
		ALG_NAME ## _mode_iv_vects, ALG_NAME ## _mode_pt_vects,			\
		ALG_NAME ## _mode_ct_vects, NUM_TESTS));				\
}

#if 0
/*
 * Counter (CTR) Mode Test Vectors.
 * From http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
 */
MODE_KEY(CTR, 0, 16,	0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c)
MODE_IV(CTR,  0, 16,	0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff)
MODE_PT(CTR,  0, 16,	0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a)
MODE_CT(CTR,  0, 16, 	0x87,0x4d,0x61,0x91,0xb6,0x20,0xe3,0x26,0x1b,0xef,0x68,0x64,0x99,0x0d,0xb6,0xce)

MODE_KEY(CTR, 1, 24,	0x8e,0x73,0xb0,0xf7,0xda,0x0e,0x64,0x52,0xc8,0x10,0xf3,0x2b,0x80,0x90,0x79,0xe5,
			0x62,0xf8,0xea,0xd2,0x52,0x2c,0x6b,0x7b)
MODE_IV(CTR,  1, 16,	0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff)
MODE_PT(CTR,  1, 16,	0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a)
MODE_CT(CTR,  1, 16,	0x1a,0xbc,0x93,0x24,0x17,0x52,0x1c,0xa2,0x4f,0x2b,0x04,0x59,0xfe,0x7e,0x6e,0x0b)

MODE_KEY(CTR, 2, 32,	0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,
			0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4)
MODE_IV(CTR,  2, 16,	0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff)
MODE_PT(CTR,  2, 16,	0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a)
MODE_CT(CTR,  2, 16,	0x60,0x1e,0xc3,0x13,0x77,0x57,0x89,0xa5,0xb7,0xa7,0xf5,0x04,0xbb,0xf3,0xd2,0x28)

MODE_TEST(CTR, 3)
#endif


/*
 * Electronic Codebook (ECB) Mode Test Vectors.
 * (The IV vectors are not used.)
 */
MODE_KEY(aes_128_ecb, 0, 16,	0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00)
MODE_IV(aes_128_ecb,  0, 1,	0x00)
MODE_PT(aes_128_ecb,  0, 16,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00)
MODE_CT(aes_128_ecb,  0, 16, 	0x0e,0xdd,0x33,0xd3,0xc6,0x21,0xe5,0x46,0x45,0x5b,0xd8,0xba,0x14,0x18,0xbe,0xc8)

MODE_KEY(aes_128_ecb, 1, 16,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f)
MODE_IV(aes_128_ecb,  1, 1,	0x00)
MODE_PT(aes_128_ecb,  1, 16,	0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff)
MODE_CT(aes_128_ecb,  1, 16,	0x69,0xc4,0xe0,0xd8,0x6a,0x7b,0x04,0x30,0xd8,0xcd,0xb7,0x80,0x70,0xb4,0xc5,0x5a)
MODE_TEST(aes_128_ecb, 2)

MODE_KEY(aes_192_ecb, 0, 24,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
			0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17)
MODE_IV(aes_192_ecb,  0, 1,	0x00)
MODE_PT(aes_192_ecb,  0, 16,	0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff)
MODE_CT(aes_192_ecb,  0, 16,	0xdd,0xa9,0x7c,0xa4,0x86,0x4c,0xdf,0xe0,0x6e,0xaf,0x70,0xa0,0xec,0x0d,0x71,0x91)
MODE_TEST(aes_192_ecb, 1)

MODE_KEY(aes_256_ecb, 0, 32,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
			0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f)
MODE_IV(aes_256_ecb,  0, 1,	0x00)
MODE_PT(aes_256_ecb,  0, 16,	0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff)
MODE_CT(aes_256_ecb,  0, 16,	0x8e,0xa2,0xb7,0xca,0x51,0x67,0x45,0xbf,0xea,0xfc,0x49,0x90,0x4b,0x49,0x60,0x89)
MODE_TEST(aes_256_ecb, 1)

/*
 * Cipher Block Chaining (CBC) Mode Test Vectors.
 * From http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
 */
MODE_KEY(aes_128_cbc, 0, 16,	0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c)
MODE_IV(aes_128_cbc,  0, 16,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f)
MODE_PT(aes_128_cbc,  0, 16,	0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a)
MODE_CT(aes_128_cbc,  0, 16,	0x76,0x49,0xab,0xac,0x81,0x19,0xb2,0x46,0xce,0xe9,0x8e,0x9b,0x12,0xe9,0x19,0x7d)
MODE_TEST(aes_128_cbc, 1)

MODE_KEY(aes_192_cbc, 0, 24,	0x8e,0x73,0xb0,0xf7,0xda,0x0e,0x64,0x52,0xc8,0x10,0xf3,0x2b,0x80,0x90,0x79,0xe5,
			0x62,0xf8,0xea,0xd2,0x52,0x2c,0x6b,0x7b)
MODE_IV(aes_192_cbc,  0, 16,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f)
MODE_PT(aes_192_cbc,  0, 16,	0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a)
MODE_CT(aes_192_cbc,  0, 16,	0x4f,0x02,0x1d,0xb2,0x43,0xbc,0x63,0x3d,0x71,0x78,0x18,0x3a,0x9f,0xa0,0x71,0xe8)
MODE_TEST(aes_192_cbc, 1)


MODE_KEY(aes_256_cbc, 0, 32,	0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,
			0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4)
MODE_IV(aes_256_cbc,  0, 16,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f)
MODE_PT(aes_256_cbc,  0, 16,	0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a)
MODE_CT(aes_256_cbc,  0, 16,	0xf5,0x8c,0x4c,0x04,0xd6,0xe5,0xf1,0xba,0x77,0x9e,0xab,0xfb,0x5f,0x7b,0xfb,0xd6)
MODE_TEST(aes_256_cbc, 1)

#if 0
/*
 * Cipher Feedback Block, 128 bit (CFB128) Mode Test Vectors.
 * From http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
 */
MODE_KEY(CFB, 0, 16,	0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c)
MODE_IV(CFB,  0, 16,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f)	
MODE_PT(CFB,  0, 16,	0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a)
MODE_CT(CFB,  0, 16,	0x3b,0x3f,0xd9,0x2e,0xb7,0x2d,0xad,0x20,0x33,0x34,0x49,0xf8,0xe8,0x3c,0xfb,0x4a)

MODE_KEY(CFB, 1, 24,	0x8e,0x73,0xb0,0xf7,0xda,0x0e,0x64,0x52,0xc8,0x10,0xf3,0x2b,0x80,0x90,0x79,0xe5,
			0x62,0xf8,0xea,0xd2,0x52,0x2c,0x6b,0x7b)
MODE_IV(CFB,  1, 16,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f)
MODE_PT(CFB,  1, 16,	0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a)
MODE_CT(CFB,  1, 16,	0xcd,0xc8,0x0d,0x6f,0xdd,0xf1,0x8c,0xab,0x34,0xc2,0x59,0x09,0xc9,0x9a,0x41,0x74)

MODE_KEY(CFB, 2, 32,	0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,
			0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4)
MODE_IV(CFB,  2, 16,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f)
MODE_PT(CFB,  2, 16,	0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a)
MODE_CT(CFB,  2, 16,	0xdc,0x7e,0x84,0xbf,0xda,0x79,0x16,0x4b,0x7e,0xcd,0x84,0x86,0x98,0x5d,0x38,0x60)

MODE_TEST(CFB, 3)

/*
 * Output Feedback Block (OFB) Mode Test Vectors.
 * From http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
 */
MODE_KEY(OFB, 0, 16,	0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c)
MODE_IV(OFB,  0, 16,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f)	
MODE_PT(OFB,  0, 16,	0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a)
MODE_CT(OFB,  0, 16,	0x3b,0x3f,0xd9,0x2e,0xb7,0x2d,0xad,0x20,0x33,0x34,0x49,0xf8,0xe8,0x3c,0xfb,0x4a)	

MODE_KEY(OFB, 1, 24,	0x8e,0x73,0xb0,0xf7,0xda,0x0e,0x64,0x52,0xc8,0x10,0xf3,0x2b,0x80,0x90,0x79,0xe5,
			0x62,0xf8,0xea,0xd2,0x52,0x2c,0x6b,0x7b)
MODE_IV(OFB,  1, 16,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f)
MODE_PT(OFB,  1, 16,	0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a)
MODE_CT(OFB,  1, 16,	0xcd,0xc8,0x0d,0x6f,0xdd,0xf1,0x8c,0xab,0x34,0xc2,0x59,0x09,0xc9,0x9a,0x41,0x74)

MODE_KEY(OFB, 2, 32,	0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,
			0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4)
MODE_IV(OFB,  2, 16,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f)
MODE_PT(OFB,  2, 16,	0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a)
MODE_CT(OFB,  2, 16,	0xdc,0x7e,0x84,0xbf,0xda,0x79,0x16,0x4b,0x7e,0xcd,0x84,0x86,0x98,0x5d,0x38,0x60)

MODE_TEST(OFB, 3)
#endif /* #if 0 */

/*
 * Cipher Feedback Block, 8 bit (CFB8) Mode Test Vectors.
 * From http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
 */
MODE_KEY(aes_128_cfb8, 0, 16,	0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c)
MODE_IV(aes_128_cfb8,  0, 16,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f)
MODE_PT(aes_128_cfb8,  0, 1,	0x6b)
MODE_CT(aes_128_cfb8,  0, 1,	0x3b)

MODE_KEY(aes_128_cfb8, 1, 16,	0xdf,0x54,0xa7,0x0f,0x60,0xbd,0xe2,0x2f,0xc6,0x7a,0x23,0x49,0x25,0x9e,0x3c,0xb4)
MODE_IV(aes_128_cfb8,  1, 16,	0x01,0x40,0xe1,0x94,0xac,0xfe,0xa9,0x77,0x8e,0xf5,0x2e,0xe8,0x78,0xbf,0x73,0x70)
MODE_PT(aes_128_cfb8,  1, 2,	0xed,0xe4)
MODE_CT(aes_128_cfb8,  1, 2,	0xa5,0x6f)
MODE_TEST(aes_128_cfb8, 2)

MODE_KEY(aes_192_cfb8, 0, 24,	0x8e,0x73,0xb0,0xf7,0xda,0x0e,0x64,0x52,0xc8,0x10,0xf3,0x2b,0x80,0x90,0x79,0xe5,
			0x62,0xf8,0xea,0xd2,0x52,0x2c,0x6b,0x7b)
MODE_IV(aes_192_cfb8,  0, 16,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f)
MODE_PT(aes_192_cfb8,  0, 1,	0x6b)
MODE_CT(aes_192_cfb8,  0, 1,	0xcd)
MODE_TEST(aes_192_cfb8, 1)

MODE_KEY(aes_256_cfb8, 0, 32,	0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,
			0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4)
MODE_IV(aes_256_cfb8,  0, 16,	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f)
MODE_PT(aes_256_cfb8,  0, 1,	0x6B)
MODE_CT(aes_256_cfb8,  0, 1,	0xdc)
MODE_TEST(aes_256_cfb8, 1)


#if 0
/*
 * RC4 pseudo mode.
 * (IV vector is not used.)
 */
MODE_KEY(RC4, 0, 8,	0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef)
MODE_IV(RC4,  0, 1,	0x00)
MODE_PT(RC4,  0, 8,	0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef)
MODE_CT(RC4,  0, 8,	0x75,0xb7,0x87,0x80,0x99,0xe0,0xc5,0x96)

MODE_KEY(RC4, 1, 8,	0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef)
MODE_IV(RC4,  1, 1,	0x00)
MODE_PT(RC4,  1, 8,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00)
MODE_CT(RC4,  1, 8,	0x74,0x94,0xc2,0xe7,0x10,0x4b,0x08,0x79)

MODE_KEY(RC4, 2, 8,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00)
MODE_IV(RC4,  2, 1,	0x00)
MODE_PT(RC4,  2, 8,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00)
MODE_CT(RC4,  2, 8,	0xde,0x18,0x89,0x41,0xa3,0x37,0x5d,0x3a)

MODE_KEY(RC4, 3, 4,	0xef,0x01,0x23,0x45)
MODE_IV(RC4,  3, 1,	0x00)
MODE_PT(RC4,  3, 20,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00)
MODE_CT(RC4,  3, 20,	0xd6,0xa1,0x41,0xa7,0xec,0x3c,0x38,0xdf,0xbd,0x61,0x5a,0x11,0x62,0xe1,0xc7,0xba,
			0x36,0xb6,0x78,0x58)

MODE_KEY(RC4, 4, 4,	0xef,0x01,0x23,0x45)
MODE_IV(RC4,  4, 1,	0x00)
MODE_PT(RC4,  4, 10,	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00)
MODE_CT(RC4,  4, 10,	0xd6,0xa1,0x41,0xa7,0xec,0x3c,0x38,0xdf,0xbd,0x61)

MODE_TEST(RC4, 5)

/*
 * XTS-AES Mode.
 * Vectors from http://csrc.nist.gov/groups/STM/cavp/documents/aes/XTSTestVectors.zip
 */
MODE_KEY(XTS,  0, 32,	0x46,0xe6,0xed,0x9e,0xf4,0x2d,0xcd,0xb3, /* Combined key */
			0xc8,0x93,0x09,0x3c,0x28,0xe1,0xfc,0x0f,
			0x91,0xf5,0xca,0xa3,0xb6,0xe0,0xbc,0x5a,
			0x14,0xe7,0x83,0x21,0x5c,0x1d,0x5b,0x61)
MODE_IV(XTS,   0, 16,	0x72,0xf3,0xb0,0x54,0xcb,0xdc,0x2f,0x9e,
 			0x3c,0x5b,0xc5,0x51,0xd4,0x4d,0xdb,0xa0)
MODE_PT(XTS,   0, 16, 	0xe3,0x77,0x8d,0x68,0xe7,0x30,0xef,0x94,
			0x5b,0x4a,0xe3,0xbc,0x5b,0x93,0x6b,0xdd)
MODE_CT(XTS,   0, 16,	0x97,0x40,0x9f,0x1f,0x71,0xae,0x45,0x21,
			0xcb,0x49,0xa3,0x29,0x73,0xde,0x4d,0x05)

MODE_KEY(XTS,  1, 32,	0xc1,0x7c,0x37,0x2b,0x56,0x26,0x91,0x6d, /* Combined key */
			0x98,0xc0,0x26,0x29,0xf5,0xd2,0x76,0x47,
			0x45,0x57,0xe3,0xfe,0xaa,0x75,0x78,0x36,
			0x34,0xd5,0x5f,0x15,0x4e,0x0a,0x8d,0x18)
MODE_IV(XTS,   1, 16,	0xdc,0x05,0x22,0x15,0xba,0x65,0x5c,0xce,
			0x70,0x7e,0x51,0x3d,0x54,0x3a,0x50,0x85)
MODE_PT(XTS,   1, 32,	0xe9,0xb9,0xe2,0x9f,0xdf,0xa1,0xaf,0x53,
			0x5a,0x1e,0xc5,0x0e,0xd9,0x20,0x4f,0x75,
			0xc6,0x2f,0x40,0xa9,0xa1,0x9e,0x50,0x49,
			0xcc,0x10,0x48,0xe7,0x04,0x7b,0x8a,0xcb)
MODE_CT(XTS,   1, 32,	0xb7,0xb4,0x16,0xa5,0x6c,0xc3,0x2f,0x75,
			0x3c,0x25,0x9b,0x94,0x3e,0xa0,0x7a,0x9d,
			0xc0,0x30,0x84,0x0c,0x80,0x55,0x83,0x1e,
			0x22,0x31,0xf7,0xbf,0xbd,0x0a,0x73,0x4b)

MODE_TEST(XTS, 2)

/* XXX Need test vectors for the following: */
/*
MODE_NOTEST(F8)
MODE_NOTEST(LRW)
*/
#endif /* #if 0 */

/*
 * Mode test functions array.
 */
static testFunction_t modeTestFunctions[] = {
    { testMode_aes_128_ecb,	"aes-128-ecb" },
    { testMode_aes_192_ecb,	"aes-192-ecb" },
    { testMode_aes_256_ecb,	"aes-256-ecb" },
    { testMode_aes_128_cbc,	"aes-128-cbc" },
    { testMode_aes_192_cbc,	"aes-192-cbc" },
    { testMode_aes_256_cbc,	"aes-256-cbc" },
#if 0
    { testModeCFB,	"CFB" },
    { testModeCTR,	"CTR" },
    { testModeF8,	"F8" },	
    { testModeLRW,	"LRW" },
    { testModeOFB,	"OFB" },
    { testModeXTS,	"XTS" },
    { testModeRC4,	"RC4" },
#endif
    { testMode_aes_128_cfb8,	"aes-128-cfb8" },
    { testMode_aes_192_cfb8,	"aes-192-cfb8" },
    { testMode_aes_256_cfb8,	"aes-256-cfb8" },
};
#define	numModeTestFunctions	(sizeof(modeTestFunctions) / sizeof(modeTestFunctions[0]))

static int
testAllModes(void)
{
	unsigned i;
	int err = 0;
	int prev_fail = fail;

	for (i = 0; i < numModeTestFunctions; i++) {
		if (NULL == modeTestFunctions[i].description) continue;
		if (verbose) printf("[BEGIN] %s\n",  modeTestFunctions[i].description);
		err = modeTestFunctions[i].funcptr();
		total++;
		if (err) {
			fail++;
			if (verbose) printf("[FAIL] %s\n", modeTestFunctions[i].description);
		} else {
			pass++;
			if (verbose) printf("[PASS] %s\n", modeTestFunctions[i].description);
		}
	}
	return (fail - prev_fail);
}


static struct option args[] = {
	{ "help",	no_argument,	NULL,	'h' },
	{ "quite",	no_argument,	NULL, 	'q' },
	{ 0, 0, 0, 0 }
};

static void
usage (int ret)
{
    fprintf(stderr, "usage: %s [--quite/-q] [--help/-h]\n", getprogname());
    exit (ret);
}

int
main(int argc, char **argv)
{
    int i, idx = 0, rv = 0;

    setprogname(argv[0]);

    while(1) {
	    int c = getopt_long(argc, argv, "hq", args, &idx);

	    if (c == -1)
		    break;
	    switch (c) {
	    case 'q':
		    verbose = 0;
		    break;
	    case 'h':
		    usage(0);
		    break;
	    case '?':
	    default:
		    usage(-1);
		    break;
	    }
    }

    /*
    argc -= idx;
    argv += idx;
    */

    if (verbose) printf("[TEST] Cryptor KATs\n");
    rv = testAllCryptors() + testAllModes();
    if (verbose) {
	    printf("[SUMMARY]\n");
	    printf("Total: %d\n", total);
	    printf("passed: %d\n", pass);
	    printf("failed: %d\n", fail);
    }

    return (rv);
}

